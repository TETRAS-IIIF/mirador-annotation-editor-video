<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: es/annotationForm/AnnotationFormOverlay/AnnotationDrawing.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: es/annotationForm/AnnotationFormOverlay/AnnotationDrawing.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationDrawing;
var _react = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _reactKonva = require("react-konva");
var _uuid = require("uuid");
var _ParentComponent = _interopRequireDefault(require("./KonvaDrawing/shapes/ParentComponent"));
var _KonvaUtils = require("./KonvaDrawing/KonvaUtils");
function _interopRequireDefault(e) { return e &amp;&amp; e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r &amp;&amp; e &amp;&amp; e.__esModule) return e; if (null === e || "object" != typeof e &amp;&amp; "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t &amp;&amp; t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u &amp;&amp; {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i &amp;&amp; (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t &amp;&amp; t.set(e, n), n; }
/** All the stuff to draw on the canvas */
function AnnotationDrawing({
  displayMode,
  drawingState,
  playerReferences,
  scale,
  setColorToolFromCurrentShape,
  setDrawingState,
  setToolState,
  tabView,
  toolState,
  updateCurrentShapeInShapes,
  updateScale,
  windowId
}) {
  const width = playerReferences.getMediaTrueWidth();
  const [isDrawing, setIsDrawing] = (0, _react.useState)(false);

  // This useEffect is necessary to update the scale when the window is resized. If not drawing
  // stage is not aligned with the image.
  (0, _react.useEffect)(() => {
    updateScale(playerReferences.getZoom());
  }, [{
    width
  }]);
  (0, _react.useEffect)(() => {
    if (toolState.imageEvent?.id &amp;&amp; !drawingState.currentShape) {
      const imageShape = {
        id: (0, _uuid.v4)(),
        rotation: 0,
        scaleX: 0.2,
        scaleY: 0.2,
        type: _KonvaUtils.OVERLAY_TOOL.IMAGE,
        url: toolState.imageEvent.id,
        x: 60,
        y: 60
      };
      setDrawingState({
        ...drawingState,
        currentShape: imageShape,
        shapes: [...drawingState.shapes, imageShape]
      });
    }
    setIsDrawing(false);
  }, [toolState]);
  (0, _react.useEffect)(() => {
    if (!isDrawing) {
      const newCurrentShape = drawingState[drawingState.shapes.length - 1];
      // get the latest shape in the list
      if (newCurrentShape) {
        updateCurrentShapeInShapes(newCurrentShape);
      }
    }
  }, [drawingState]);
  (0, _react.useEffect)(() => {
    // Perform an action when fillColor, strokeColor, or strokeWidth change
    // update current shape
    if (drawingState.currentShape) {
      // eslint-disable-next-line no-param-reassign
      drawingState.currentShape.fill = toolState.fillColor;
      // eslint-disable-next-line no-param-reassign
      drawingState.currentShape.stroke = toolState.strokeColor;
      // eslint-disable-next-line no-param-reassign
      drawingState.currentShape.strokeWidth = toolState.strokeWidth;
      // eslint-disable-next-line no-param-reassign
      drawingState.currentShape.text = toolState.text;
      updateCurrentShapeInShapes(drawingState.currentShape);
    }
  }, [toolState]);

  // eslint-disable-next-line consistent-return
  (0, _react.useLayoutEffect)(() => {
    if (drawingState.shapes.find(s => s.id === drawingState.currentShape?.id)) {
      window.addEventListener('keydown', handleKeyPress);

      // Set here all the properties of the current shape for the tool options
      setColorToolFromCurrentShape({
        fillColor: drawingState.currentShape.fill,
        strokeColor: drawingState.currentShape.stroke,
        strokeWidth: drawingState.currentShape.strokeWidth,
        text: drawingState.currentShape.text
      });
      return () => {
        window.removeEventListener('keydown', handleKeyPress);
      };
    }
  }, [drawingState.currentShape]);

  /** */
  const handleKeyPress = e => {
    e.stopPropagation();
    if (!drawingState.currentShape) {
      return;
    }
    if (e.key === 'Delete') {
      // eslint-disable-next-line max-len
      const shapesWithoutTheDeleted = drawingState.shapes.filter(shape => shape.id !== drawingState.currentShape.id);
      setDrawingState({
        ...drawingState,
        currentShape: null,
        shapes: shapesWithoutTheDeleted
      });
      setToolState({
        ...toolState,
        imageEvent: null
      });
      return;
    }

    // release the drawing
    if (e.key === 'Escape') {
      if (toolState.activeTool === _KonvaUtils.OVERLAY_TOOL.IMAGE) {
        return;
      }
      if (toolState.activeTool === _KonvaUtils.SHAPES_TOOL.POLYGON) {
        drawingState.currentShape.points.splice(-2, 2);
        updateCurrentShapeInShapes({
          points: [drawingState.currentShape.points],
          ...drawingState.currentShape
        });
      }
      setDrawingState({
        ...drawingState,
        currentShape: null,
        isDrawing: false
      });
      return;
    }
    if (drawingState.currentShape.type === 'text') {
      const newCurrentShape = {
        ...drawingState.currentShape
      };
      setDrawingState(prevState => ({
        ...prevState,
        currentShape: newCurrentShape,
        shapes: prevState.shapes.map(shape => shape.id === newCurrentShape.id ? {
          ...shape,
          ...newCurrentShape
        } : shape)
      }));
    }
  };

  /** */
  const onShapeClick = async shp => {
    // return if we are not in edit or cursor mode
    if (toolState.activeTool !== 'edit' &amp;&amp; toolState.activeTool !== 'cursor' &amp;&amp; toolState.activeTool !== 'delete') {
      return;
    }
    const shape = drawingState.shapes.find(s => s.id === shp.id);
    if (toolState.activeTool === 'delete') {
      const newShapes = drawingState.shapes.filter(s => s.id !== shape.id);
      setDrawingState({
        ...drawingState,
        currentShape: null,
        shapes: newShapes
      });
      return;
    }
    setDrawingState({
      ...drawingState,
      currentShape: shape
    });
    setColorToolFromCurrentShape({
      fillColor: shape.fill,
      strokeColor: shape.stroke,
      strokeWidth: shape.strokeWidth
    });
  };

  /**
   * Handles the transformation event on a shape. It updates the shape's properties
   * with the modified attributes from the event target, finds the corresponding shape
   * in the global state by ID, and updates the current shape in the global shapes array.
   * Finally, it invokes the update function to reflect these changes in the global state.
   *
   * @param {Object} evt - The event object containing the target shape's modified attributes.
   */
  const onTransform = evt => {
    const modifiedShape = evt.target.attrs;
    const shape = drawingState.shapes.find(s => s.id === modifiedShape.id);
    Object.assign(shape, modifiedShape);
    if (shape.type === _KonvaUtils.OVERLAY_TOOL.IMAGE) {
      shape.width = modifiedShape.image.width * modifiedShape.scaleX;
      shape.height = modifiedShape.image.height * modifiedShape.scaleY;
    }
    updateCurrentShapeInShapes(shape);
  };

  /**
   * Handles the drag end event for a shape.
   * @param {Event} evt - The drag end event object.
   */
  const handleDragEnd = evt => {
    const editedShape = evt.currentTarget.attrs;
    const shape = drawingState.shapes.find(s => s.id === editedShape.id);
    Object.assign(shape, editedShape);
    shape.x = editedShape.x;
    shape.y = editedShape.y;
    if (shape.type === _KonvaUtils.SHAPES_TOOL.IMAGE) {
      shape.width = editedShape.image.width * editedShape.scaleX;
      shape.height = editedShape.image.height * editedShape.scaleY;
    }
  };

  /**
   * Handles the drag start event.
   * @param {Event} evt - The drag start event object.
   * @returns {void}
   */
  const handleDragStart = evt => {
    const editedShape = evt.currentTarget.attrs;
    setDrawingState({
      ...drawingState,
      currentShape: drawingState.shapes.find(s => s.id === editedShape.id)
    });
  };

  /** */
  const handleMouseDown = e => {
    try {
      const pos = e.target.getStage().getRelativePointerPosition();
      pos.x /= scale;
      pos.y /= scale;
      let shape = null;
      switch (toolState.activeTool) {
        case _KonvaUtils.SHAPES_TOOL.RECTANGLE:
          shape = {
            fill: toolState.fillColor,
            height: 30,
            id: (0, _uuid.v4)(),
            scaleX: 1,
            scaleY: 1,
            stroke: toolState.strokeColor,
            strokeWidth: toolState.strokeWidth,
            type: toolState.activeTool,
            width: 30,
            x: pos.x,
            y: pos.y
          };
          setDrawingState({
            currentShape: shape,
            isDrawing: true,
            shapes: [...drawingState.shapes, shape]
          });
          break;
        case _KonvaUtils.SHAPES_TOOL.ELLIPSE:
          shape = {
            fill: toolState.fillColor,
            height: 1,
            id: (0, _uuid.v4)(),
            radiusX: 1,
            radiusY: 1,
            rotation: 0,
            scaleX: 1,
            scaleY: 1,
            stroke: toolState.strokeColor,
            strokeWidth: toolState.strokeWidth,
            type: toolState.activeTool,
            width: 1,
            x: pos.x,
            y: pos.y
          };
          setDrawingState({
            currentShape: shape,
            isDrawing: true,
            shapes: [...drawingState.shapes, shape]
          });
          break;
        case _KonvaUtils.SHAPES_TOOL.CIRCLE:
          shape = {
            fill: toolState.fillColor,
            height: 1,
            id: (0, _uuid.v4)(),
            radius: 1,
            rotation: 0,
            scaleX: 1,
            scaleY: 1,
            stroke: toolState.strokeColor,
            strokeWidth: toolState.strokeWidth,
            type: toolState.activeTool,
            width: 1,
            x: pos.x,
            y: pos.y
          };
          setDrawingState({
            currentShape: shape,
            isDrawing: true,
            shapes: [...drawingState.shapes, shape]
          });
          break;
        case _KonvaUtils.OVERLAY_TOOL.TEXT:
          shape = {
            fill: toolState.fillColor,
            fontSize: 20,
            id: (0, _uuid.v4)(),
            rotation: 0,
            scaleX: 1,
            scaleY: 1,
            text: 'Change me',
            type: _KonvaUtils.OVERLAY_TOOL.TEXT,
            x: pos.x,
            y: pos.y
          };
          setDrawingState({
            ...drawingState,
            currentShape: shape,
            shapes: [...drawingState.shapes, shape]
          });
          break;
        case _KonvaUtils.SHAPES_TOOL.FREEHAND:
          shape = {
            fill: toolState.fillColor,
            id: (0, _uuid.v4)(),
            lines: [{
              points: [pos.x, pos.y, pos.x, pos.y],
              stroke: toolState.strokeColor,
              strokeWidth: toolState.strokeWidth,
              x: 0,
              y: 0
            }],
            rotation: 0,
            scaleX: 1,
            scaleY: 1,
            stroke: toolState.strokeColor,
            strokeWidth: toolState.strokeWidth,
            type: _KonvaUtils.SHAPES_TOOL.FREEHAND,
            x: 0,
            y: 0
          };
          setDrawingState({
            currentShape: shape,
            isDrawing: true,
            shapes: [...drawingState.shapes, shape]
          });
          break;
        case _KonvaUtils.SHAPES_TOOL.POLYGON:
          if (drawingState.isDrawing) {
            drawingState.currentShape.points.splice(-2, 2, pos.x, pos.y);
            drawingState.currentShape.points.push(pos.x, pos.y);
            updateCurrentShapeInShapes({
              points: [drawingState.currentShape.points],
              ...drawingState.currentShape
            });
          } else {
            shape = {
              fill: toolState.fillColor,
              id: (0, _uuid.v4)(),
              points: [pos.x, pos.y, pos.x, pos.y],
              rotation: 0,
              scaleX: 1,
              scaleY: 1,
              stroke: toolState.strokeColor,
              strokeWidth: toolState.strokeWidth,
              type: _KonvaUtils.SHAPES_TOOL.POLYGON,
              x: 0,
              y: 0
            };
            setDrawingState({
              currentShape: shape,
              isDrawing: true,
              shapes: [...drawingState.shapes, shape]
            });
            setIsDrawing(true);
          }
          break;
        case _KonvaUtils.SHAPES_TOOL.ARROW:
          shape = {
            fill: toolState.fillColor,
            id: (0, _uuid.v4)(),
            pointerLength: 20,
            pointerWidth: 20,
            points: [pos.x, pos.y, pos.x, pos.y],
            rotation: 0,
            scaleX: 1,
            scaleY: 1,
            stroke: toolState.strokeColor,
            strokeWidth: toolState.strokeWidth,
            type: _KonvaUtils.SHAPES_TOOL.ARROW
          };
          setDrawingState({
            currentShape: shape,
            isDrawing: true,
            shapes: [...drawingState.shapes, shape]
          });
          break;
        default:
          // Handle other cases if any
          break;
      }
    } catch (error) {
      console.error('error', error);
    }
  };

  /** */
  const handleMouseMove = e => {
    try {
      if (!drawingState.isDrawing) {
        return;
      }
      if (!drawingState.currentShape) {
        return;
      }
      const pos = e.target.getStage().getRelativePointerPosition();
      pos.x /= scale;
      pos.y /= scale;
      switch (toolState.activeTool) {
        case _KonvaUtils.SHAPES_TOOL.RECTANGLE:
          updateCurrentShapeInShapes({
            ...drawingState.currentShape,
            height: pos.y - drawingState.currentShape.y,
            width: pos.x - drawingState.currentShape.x
          });
          break;
        case _KonvaUtils.SHAPES_TOOL.ELLIPSE:
          // prevent negative radius for ellipse
          if (pos.x &lt; drawingState.currentShape.x) {
            pos.x = drawingState.currentShape.x;
          }
          if (pos.y &lt; drawingState.currentShape.y) {
            pos.y = drawingState.currentShape.y;
          }
          updateCurrentShapeInShapes({
            ...drawingState.currentShape,
            height: pos.y - drawingState.currentShape.y,
            radiusX: (pos.x - drawingState.currentShape.x) / 2,
            radiusY: (pos.y - drawingState.currentShape.y) / 2,
            width: pos.x - drawingState.currentShape.x
          });
          break;
        case _KonvaUtils.SHAPES_TOOL.CIRCLE:
          if (pos.x &lt; drawingState.currentShape.x) {
            pos.x = drawingState.currentShape.x;
          }
          if (pos.y &lt; drawingState.currentShape.y) {
            pos.y = drawingState.currentShape.y;
          }
          const radius = Math.sqrt((pos.x - drawingState.currentShape.x) ** 2 + (pos.y - drawingState.currentShape.y) ** 2);
          updateCurrentShapeInShapes({
            ...drawingState.currentShape,
            radius
          });
          break;
        case _KonvaUtils.SHAPES_TOOL.FREEHAND:
          // eslint-disable-next-line react/prop-types
          drawingState.lines.push({
            points: [pos.x, pos.y, pos.x, pos.y],
            stroke: toolState.strokeColor,
            strokeWidth: toolState.strokeWidth
          });
          updateCurrentShapeInShapes({
            ...drawingState.currentShape
          });
          break;
        case _KonvaUtils.SHAPES_TOOL.POLYGON:
          drawingState.currentShape.points.splice(-2, 2, pos.x, pos.y);
          updateCurrentShapeInShapes({
            ...drawingState.currentShape
          });
          break;
        case _KonvaUtils.SHAPES_TOOL.ARROW:
          updateCurrentShapeInShapes({
            ...drawingState.currentShape,
            fill: toolState.fillColor,
            points: [drawingState.currentShape.points[0], drawingState.currentShape.points[1], pos.x, pos.y],
            stroke: toolState.strokeColor,
            strokeWidth: toolState.strokeWidth
          });
          setIsDrawing(true);
          break;
        default:
          break;
      }
    } catch (error) {
      console.error('error', error);
    }
  };

  /** Stop drawing */
  const handleMouseUp = () => {
    if (toolState.activeTool !== _KonvaUtils.SHAPES_TOOL.POLYGON) {
      setDrawingState({
        ...drawingState,
        isDrawing: false
      });
    }
  };

  /** */
  const drawKonvas = () => /*#__PURE__*/_react.default.createElement(_reactKonva.Stage, {
    width: playerReferences.getDisplayedMediaWidth(),
    height: playerReferences.getDisplayedMediaHeight(),
    style: {
      height: 'auto',
      left: playerReferences.getImagePosition().x,
      objectFit: 'contain',
      overflow: 'clip',
      overflowClipMargin: 'content-box',
      position: 'absolute',
      top: playerReferences.getImagePosition().y
    },
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onMouseMove: handleMouseMove,
    id: windowId
  }, /*#__PURE__*/_react.default.createElement(_ParentComponent.default, {
    activeTool: toolState.activeTool,
    baseStrokeWidth: playerReferences.getTargetStrokeWidth(),
    displayMode: displayMode,
    handleDragEnd: handleDragEnd,
    handleDragStart: handleDragStart,
    onShapeClick: onShapeClick,
    onTransform: onTransform,
    scale: scale,
    selectedShapeId: drawingState.currentShape?.id,
    shapes: drawingState.shapes,
    trview: tabView !== 'target'
  }));

  /** ***************************
   * Return
   **************************** */
  const container = playerReferences.getContainer();
  if (container) {
    return /*#__PURE__*/_reactDom.default.createPortal(drawKonvas(), container);
  }
  // eslint-disable-next-line react/jsx-no-useless-fragment
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null);
}
const shapeObjectPropTypes = _propTypes.default.shape({
  fill: _propTypes.default.string,
  id: _propTypes.default.string,
  lines: {
    pointerLength: _propTypes.default.number,
    points: _propTypes.default.arrayOf([_propTypes.default.number]),
    stroke: _propTypes.default.string,
    strokeWidth: _propTypes.default.number
  },
  pointerLength: _propTypes.default.number,
  pointerWidth: _propTypes.default.number,
  points: _propTypes.default.number,
  rotation: _propTypes.default.number,
  scaleX: _propTypes.default.number,
  scaleY: _propTypes.default.number,
  stroke: _propTypes.default.string,
  strokeWidth: _propTypes.default.number,
  text: _propTypes.default.string,
  type: _propTypes.default.string,
  url: _propTypes.default.string,
  x: _propTypes.default.number,
  y: _propTypes.default.number
});
AnnotationDrawing.propTypes = {
  displayMode: _propTypes.default.string.isRequired,
  drawingState: _propTypes.default.oneOfType([_propTypes.default.shape({
    currentShape: shapeObjectPropTypes,
    isDrawing: _propTypes.default.bool,
    shapes: _propTypes.default.arrayOf(shapeObjectPropTypes)
  }), _propTypes.default.arrayOf(_propTypes.default.shape({
    currentShape: _propTypes.default.shape({
      id: _propTypes.default.string,
      rotation: _propTypes.default.number,
      scaleX: _propTypes.default.number,
      scaleY: _propTypes.default.number,
      type: _propTypes.default.string,
      url: _propTypes.default.string,
      x: _propTypes.default.number,
      y: _propTypes.default.number
    }),
    isDrawing: _propTypes.default.bool,
    shapes: _propTypes.default.arrayOf(_propTypes.default.shape({
      id: _propTypes.default.string,
      rotation: _propTypes.default.number,
      scaleX: _propTypes.default.number,
      scaleY: _propTypes.default.number,
      type: _propTypes.default.string,
      url: _propTypes.default.string,
      x: _propTypes.default.number,
      y: _propTypes.default.number
    }))
  }))]).isRequired,
  // eslint-disable-next-line react/forbid-prop-types
  playerReferences: _propTypes.default.object.isRequired,
  scale: _propTypes.default.number.isRequired,
  setColorToolFromCurrentShape: _propTypes.default.func.isRequired,
  setDrawingState: _propTypes.default.func.isRequired,
  setToolState: _propTypes.default.func.isRequired,
  tabView: _propTypes.default.string.isRequired,
  toolState: _propTypes.default.oneOfType(_propTypes.default.string, _propTypes.default.string, _propTypes.default.string, _propTypes.default.oneOfType(_propTypes.default.string), _propTypes.default.string, _propTypes.default.string, _propTypes.default.number).isRequired,
  updateCurrentShapeInShapes: _propTypes.default.func.isRequired,
  updateScale: _propTypes.default.func.isRequired,
  windowId: _propTypes.default.string.isRequired
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnnotationExportDialog.html">AnnotationExportDialog</a></li><li><a href="AnnototAdapter.html">AnnototAdapter</a></li><li><a href="ListItemContent.html">ListItemContent</a></li><li><a href="LocalStorageAdapter.html">LocalStorageAdapter</a></li><li><a href="ManifestNetworkFormSection.html">ManifestNetworkFormSection</a></li><li><a href="ShapesList.html">ShapesList</a></li><li><a href="SimpleAnnotationServerV2Adapter.html">SimpleAnnotationServerV2Adapter</a></li><li><a href="SingleCanvasDialog.html">SingleCanvasDialog</a></li><li><a href="TargetFormSection.html">TargetFormSection</a></li><li><a href="TextFormSection.html">TextFormSection</a></li><li><a href="WhoAndWhenFormSection.html">WhoAndWhenFormSection</a></li><li><a href="global.html#WindowPlayer">WindowPlayer</a></li><li><a href="module.html#.exports">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AdvancedAnnotationEditor">AdvancedAnnotationEditor</a></li><li><a href="global.html#AnnotationDrawing">AnnotationDrawing</a></li><li><a href="global.html#AnnotationForm">AnnotationForm</a></li><li><a href="global.html#AnnotationFormBody">AnnotationFormBody</a></li><li><a href="global.html#AnnotationFormFooter">AnnotationFormFooter</a></li><li><a href="global.html#AnnotationFormHeader">AnnotationFormHeader</a></li><li><a href="global.html#AnnotationFormOverlay">AnnotationFormOverlay</a></li><li><a href="global.html#AnnotationFormOverlayTool">AnnotationFormOverlayTool</a></li><li><a href="global.html#AnnotationFormOverlayToolOptions">AnnotationFormOverlayToolOptions</a></li><li><a href="global.html#AnnotationFormTemplateSelector">AnnotationFormTemplateSelector</a></li><li><a href="global.html#ArrowNode">ArrowNode</a></li><li><a href="global.html#CanvasAnnotationsWrapper">CanvasAnnotationsWrapper</a></li><li><a href="global.html#CircleNode">CircleNode</a></li><li><a href="global.html#ColorPicker">ColorPicker</a></li><li><a href="global.html#CursorIcon">CursorIcon</a></li><li><a href="global.html#DrawingTemplate">DrawingTemplate</a></li><li><a href="global.html#EllipseNode">EllipseNode</a></li><li><a href="global.html#ExternalStorageAnnotation">ExternalStorageAnnotation</a></li><li><a href="global.html#FragmentSelector">FragmentSelector</a></li><li><a href="global.html#Freehand">Freehand</a></li><li><a href="global.html#HMSInput">HMSInput</a></li><li><a href="global.html#IIIFTemplate">IIIFTemplate</a></li><li><a href="global.html#ImageCommentTemplate">ImageCommentTemplate</a></li><li><a href="global.html#ImageFormField">ImageFormField</a></li><li><a href="global.html#ImageShape">ImageShape</a></li><li><a href="global.html#LineNode">LineNode</a></li><li><a href="global.html#MiradorAnnotation">MiradorAnnotation</a></li><li><a href="global.html#NetworkCommentTemplate">NetworkCommentTemplate</a></li><li><a href="global.html#ParentComponent">ParentComponent</a></li><li><a href="global.html#Polygon">Polygon</a></li><li><a href="global.html#Rectangle">Rectangle</a></li><li><a href="global.html#SpatialTarget">SpatialTarget</a></li><li><a href="global.html#TEMPLATE_TYPES">TEMPLATE_TYPES</a></li><li><a href="global.html#TaggingTemplate">TaggingTemplate</a></li><li><a href="global.html#TargetSpatialInput">TargetSpatialInput</a></li><li><a href="global.html#TargetTimeInput">TargetTimeInput</a></li><li><a href="global.html#TextCommentTemplate">TextCommentTemplate</a></li><li><a href="global.html#TextEditor">TextEditor</a></li><li><a href="global.html#TextNode">TextNode</a></li><li><a href="global.html#WindowSideBarButtonWrapper">WindowSideBarButtonWrapper</a></li><li><a href="global.html#all">all</a></li><li><a href="global.html#annotationPageId">annotationPageId</a></li><li><a href="global.html#baseConfig">baseConfig</a></li><li><a href="global.html#checkMediaType">checkMediaType</a></li><li><a href="global.html#convertAnnotationStateToBeSaved">convertAnnotationStateToBeSaved</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createAnnotationPage">createAnnotationPage</a></li><li><a href="global.html#createV2Anno">createV2Anno</a></li><li><a href="global.html#createV2AnnoBody">createV2AnnoBody</a></li><li><a href="global.html#createV2AnnoSelector">createV2AnnoSelector</a></li><li><a href="global.html#createV3Anno">createV3Anno</a></li><li><a href="global.html#createV3AnnoBody">createV3AnnoBody</a></li><li><a href="global.html#createV3AnnoSelector">createV3AnnoSelector</a></li><li><a href="global.html#delete">delete</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getCurrentDateLocaleString">getCurrentDateLocaleString</a></li><li><a href="global.html#getIIIFTargetAsFragmentSVGSelector">getIIIFTargetAsFragmentSVGSelector</a></li><li><a href="global.html#getIIIFTargetFromImageType">getIIIFTargetFromImageType</a></li><li><a href="global.html#getIIIFTargetFromKonvaType">getIIIFTargetFromKonvaType</a></li><li><a href="global.html#getIIIFTargetFromMaeData">getIIIFTargetFromMaeData</a></li><li><a href="global.html#getIIIFTargetFromRectangleShape">getIIIFTargetFromRectangleShape</a></li><li><a href="global.html#getIIIFTargetFullCanvas">getIIIFTargetFullCanvas</a></li><li><a href="global.html#getKonvaAsDataURL">getKonvaAsDataURL</a></li><li><a href="global.html#getKonvaShape">getKonvaShape</a></li><li><a href="global.html#getKonvaStage">getKonvaStage</a></li><li><a href="global.html#getStorageAdapterUser">getStorageAdapterUser</a></li><li><a href="global.html#getSvg">getSvg</a></li><li><a href="global.html#getTargetSVGToolState">getTargetSVGToolState</a></li><li><a href="global.html#getTemplateType">getTemplateType</a></li><li><a href="global.html#handleClick-Theshapeobjectrepresentingthepropertiesoftheclickedshape.">handleClick
- The shape object representing the properties of the clicked shape.</a></li><li><a href="global.html#handleDelete">handleDelete</a></li><li><a href="global.html#handleEdit">handleEdit</a></li><li><a href="global.html#handleResize">handleResize</a></li><li><a href="global.html#hideKonvaStage">hideKonvaStage</a></li><li><a href="global.html#isAnnotationExportableToImage">isAnnotationExportableToImage</a></li><li><a href="global.html#isShapesTool">isShapesTool</a></li><li><a href="global.html#isValidUrl">isValidUrl</a></li><li><a href="global.html#mapDispatchToProps">mapDispatchToProps</a></li><li><a href="global.html#mapStateToProps">mapStateToProps</a></li><li><a href="global.html#objToRgba">objToRgba</a></li><li><a href="global.html#resizeKonvaStage">resizeKonvaStage</a></li><li><a href="global.html#rgbaToObj">rgbaToObj</a></li><li><a href="global.html#saveAnnotationInStorageAdapter">saveAnnotationInStorageAdapter</a></li><li><a href="global.html#secondsToHMSarray">secondsToHMSarray</a></li><li><a href="global.html#showKonvaStage">showKonvaStage</a></li><li><a href="global.html#styles">styles</a></li><li><a href="global.html#update">update</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Mar 25 2025 16:41:51 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
